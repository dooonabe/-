# 线程

## 线程安全
当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，（每次）调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

*we know when we see*

*线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施*。

### 线程安全的实现
- 阻塞（互斥）同步:`synchronized`,`ReetrantLock` 
- 非阻塞同步:`CAS`
- 无同步:`ThreadLocal`

## 线程死锁
### 产生死锁的必要条件

- 互斥

某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- 占有且等待

一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
- 不可抢占

别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。

- 循环等待

存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

## 线程间的协作

### wait
### notify
### sleep
### yield
### join

## 线程开销

1. 上下文切换
2. 内存同步

`synchronized`,`volatile`使用了内存屏障。内存屏障可以刷新缓存，使缓存无效，刷新硬件的写缓存，以及停止执行管道以及禁止指令的重排序。

现代的JVM会对锁进行消除优化：

```Java
//同步锁只能由一个线程获得
synchronized(new Object()){
    // do something
}
```
```Java
//JVM escape analysis找出不会发布到堆的本地对象引用，进行锁消除
public String getStr(){
    // Vector是同步容器
    List<String> result = new Vector<String>();
    result.add("U2");
    return result.toString();
}
```
3. 阻塞

发生阻塞之后，JVM可以采用**自旋等待**或者**上下文切换**来处理被阻塞的线程。
```Java
// 排号(ticket)自旋锁的实现
// 非适应性自选
private int volatile num;
    //todo



```

### 减少锁竞争(开销)
1. 减少锁的持有时间

缩小同步块代码，将实际不需同步执行的代码移除同步块，提高伸缩性。

> 伸缩性：当增加计算资源时，程序的吞吐量(多少)或者处理能力(多块)是否能相应的增加。在并发程序中，对伸缩性的主要威胁就是独占方式的资源锁。

2. 降低锁的请求频率

锁分解：全局锁减小为对象锁，对象锁减小为方法锁，方法锁减小为代码块锁。

锁分段：使用一组锁实现对整个对象的同步。

避免热点：计数器很容易成为热点域。
```Java
// ConcurrentHashMap 记录每一组的数量，总的数量是组的和
private transient volatile CounterCell[] counterCells;

final long sumCount() {
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
```

3. 使用带有协调机制的独占锁

并发容器，读写锁，不可变对象，原子变量，消除同步变量(ThreadLocal)。


## 实战
如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方法可以修复这个问题
### 不在线程之间共享该状态变量
- 问题场景

JStorm任务中缓存的数据对象，会被定时清理。如果使用另外的线程定时操作缓存对象，会造成多线程访问同一个可变的状态变量的情况，一不小心就会产生线程不安全问题。
- 解决方案

使用同步机制：设置tick tuple，使得操作缓存对象的线程只有一个。

### 将状态变量修改为不可变的变量


### 在访问状态变量时使用同步
- 问题场景

商品库存增减场景
- 解决方案

对同一商品ID的库存访问进行多线程同步。