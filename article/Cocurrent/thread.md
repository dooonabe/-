# 线程之间
## 线程安全
当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，（每次）调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

*线程安全类中封装了必要的同步机制，因此客户端无需进一步采取同步措施*。

### 线程安全的实现
- 阻塞（互斥）同步:`synchronized`,`ReetrantLock` 
- 非阻塞同步:`CAS`
- 无同步:`ThreadLocal`

## 产生死锁的必要条件

- 互斥

某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- 占有且等待

一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
- 不可抢占

别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。

- 循环等待

存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

## 线程间的协作

### wait
### notify
### sleep
### yield
### join


## action
如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方法可以修复这个问题
### 不在线程之间共享该状态变量
- 问题场景
JStorm任务中缓存的数据对象，会被定时清理。如果使用另外的新线程定时操作缓存对象，会造成多线程访问同一个可变的状态变量的情况，一不小心就会产生线程不安全问题。
- 解决方案
设置tick tuple，使得操作缓存对象的线程只有一个。

### 将状态变量修改为不可变的变量


### 在访问状态变量时使用同步
- 问题场景
商品库存增减场景
- 解决方案
对同一商品ID的库存访问进行多线程同步。


